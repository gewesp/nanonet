//
// Copyright 2015 KISS Technologies GmbH, Switzerland
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//
// The 'q' construct:
// qAC - Packet was received from the client directly via a verified 
//       connection (FROMCALL=login). The callSSID following the qAC 
//       is the server's callsign-SSID.
// qAS - Packet was received from another server or generated by 
//       this server. The latter case would be for a beacon generated by 
//       the server. Due to the virtual nature of APRS-IS, use of beacon 
//       packets by servers is strongly discouraged. The callSSID 
//       following the qAS is the login or IP address of the
//       first identifiable server (see algorithm).
// qAR - Packet was received directly (via a verified connection) 
//       from an IGate using the ,I construct. The callSSID following the 
//       qAR it the callSSID of the IGate.
//

#include "cpp-lib/ogn.h"

#include <iostream>
#include <iterator>
#include <string>
#include <sstream>
#include <exception>
#include <stdexcept>
#include <algorithm>
#include <memory>

#include <cassert>

#include "cpp-lib/sys/network.h"
#include "cpp-lib/sys/syslogger.h"
#include "cpp-lib/sys/util.h"

#include "cpp-lib/assert.h"
#include "cpp-lib/error.h"
#include "cpp-lib/http.h"
#include "cpp-lib/math-util.h"
#include "cpp-lib/memory.h"
#include "cpp-lib/registry.h"
#include "cpp-lib/units.h"
#include "cpp-lib/util.h"

#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/predicate.hpp>
#include <boost/algorithm/string.hpp>


using namespace cpl::util::log;

namespace {

// DDB query: Sleep interval to wake up periodically for exit
double constexpr DDB_QUERY_SLEEP_INTERVAL = 3.0;

// vehicle type descriptions
constexpr const char* const VEHICLE_DESC_GLIDER      = "GLD";
constexpr const char* const VEHICLE_DESC_TOW_PLANE   = "TOW";
constexpr const char* const VEHICLE_DESC_HELICOPTER  = "HELI";
// 4 not assigned
constexpr const char* const VEHICLE_DESC_DROP_PLANE  = "DROP";
constexpr const char* const VEHICLE_DESC_DELTA       = "HGLD";
constexpr const char* const VEHICLE_DESC_PARAGLIDER  = "PGLD";
constexpr const char* const VEHICLE_DESC_POWER_PLANE = "PWR";
constexpr const char* const VEHICLE_DESC_JET         = "JET";
constexpr const char* const VEHICLE_DESC_UFO         = "UFO";
constexpr const char* const VEHICLE_DESC_BALLOON     = "BALLOON";
constexpr const char* const VEHICLE_DESC_AIRSHIP     = "BLIMP";
constexpr const char* const VEHICLE_DESC_UAV         = "UAV";
//14 not assigned
constexpr const char* const VEHICLE_DESC_STATIC      = "STATIC";

// Maximum plausible altitude for small aircraft
double constexpr MAX_PLAUSIBLE_ALTITUDE = 20000;

// If utc >= 0, merges the date part from utc and the time part of timeofday.
double adapt_utc(double timeofday, double utc) {
  if (utc < 0) {
    return timeofday;
  }

  // Number of seconds/day
  using cpl::units::day;

  const double date = std::floor(utc / day()) * day();
  const double candidate = date + timeofday;

  // Test whether timeofday is likely to be on date, date - 1day or date + 1day.
  const double delta[3] = { 
    std::fabs(candidate - day() - utc),
    std::fabs(candidate         - utc),
    std::fabs(candidate + day() - utc) 
  };

  auto const mindelta = std::min_element(&delta[0], &delta[0] + 3);

         if (&delta[1] == mindelta) {
    // std::cout << "# timedelta = " << candidate         - utc << std::endl ;
    return candidate        ;
  } else if (&delta[0] == mindelta) {
    // std::cout << "# timedelta = " << candidate - day() - utc << std::endl ;
    return candidate - day();
  } else {
    // std::cout << "# timedelta = " << candidate + day() - utc << std::endl ;
    return candidate + day();
  }
}


// TODO: Error handling for UTC times with leap seconds (ss may be 60)?
long hhmmss_to_seconds(const long hhmmss) {
  if (hhmmss < 0) {
    throw std::runtime_error("negative HHMMSS time");
  }
  const long ss =  hhmmss        % 100;
  const long mm = (hhmmss / 100) % 100;
  const long hh =  hhmmss / 10000     ;

  if (ss >= 60 || mm >= 60 || hh >= 24) {
    throw std::runtime_error("invalid HHMMSS time");
  }

  return ss + 60 * mm + 3600 * hh;
}

// Checks that
// (a) A conversion is performed and 
// (b) The string s ends after that conversion.
bool my_double_cast(const char* const s, double& x) {
  char* endptr = NULL;
  x = std::strtod(s, &endptr);

  // No conversion performed
  if (s == endptr) {
    return false;
  }

  // String continues
  if ('\0' != *endptr) {
    return false;
  }

  // All OK
  return true;
}

// Convert DDDDDmm.mmmm format to decimal degrees.  E.g. 45 degrees 40 minutes,
// 30 seconds would be represented as 4540.5 and the function would return
// 45.675.
double ddmm2deg(const double x) {
  assert(x >= 0);
  const double minutes = std::fmod(x, 100);
  const double degrees_100 = x - minutes;
  // assert(degrees_100 >= 0); // may fail numerically?
  return 1e-2 * degrees_100 + minutes / 60;
}

void set_latlon(
  const char* const NS, const char* const EW,
  double& lat, double& lon) {

  lat = ddmm2deg(lat);
  lon = ddmm2deg(lon);

  if ('S' == NS[0]) { lat = -lat; }
  if ('W' == EW[0]) { lon = -lon; }
}

// Support for higher precision minute values.  Stock APRS has minutes
// with two decimal places, amounting to 18.5m precision @ equator,
// cf. ddmm2deg().  This extension allows up to a factor of 91 higher
// precision: http://www.aprs.org/datum.txt
// Notice that the spec seems to contain an error.  The character
// '{' (ASCII 123) is the last one in base-91 and corresponds to 90, whereas
// datum.txt erroneously lists '}'.

// The respective 'dao' parsing code in libfap (fapint_parse_dao()):
#if 0
        else if ( 'a' <= input[0] && input[0] <= 'z' &&
                  0x21 <= input[1] && input[1] <= 0x7b &&
                  0x21 <= input[2] && input[2] <= 0x7b )
        {
                // Base-91.
                packet->dao_datum_byte = toupper(input[0]); //
                if ( packet->pos_resolution == NULL )
                {
                        packet->pos_resolution = malloc(sizeof(double));
                        if ( !packet->pos_resolution ) return 0;
                }
                *packet->pos_resolution = fapint_get_pos_resolution(4);
                // Scale base-91.
                lat_off = (input[1]-33.0)/91.0 * 0.01 / 60.0;
                lon_off = (input[2]-33.0)/91.0 * 0.01 / 60.0;
#endif

// Is this a base-91 character?
// In ASCII, this is: '!' ... '{'
inline bool isbase91(char const c) {
  return 33 <= c && c < 33 + 91;
}

bool set_latlon_dao(char const* const dao,
    double& lat,
    double& lon) {

  if (    5  != std::strlen(dao)
      || '!' != dao[0]
      || '!' != dao[4]) {
    return false;
  }

  assert(5 == std::strlen(dao));
  assert('!' == dao[0]);
  assert('!' == dao[4]);

  double dlat, dlon;

  if ('W' == dao[1]) {
    if (!(std::isdigit(dao[2]) && std::isdigit(dao[3]))) {
      return false;
    }
    dlat = (dao[2] - '0') * 1e-3 / cpl::units::minute();
    dlon = (dao[3] - '0') * 1e-3 / cpl::units::minute();
  } else if ('w' == dao[1]) {
    if (!(isbase91(dao[2]) && isbase91(dao[3]))) {
      return false;
    }
    dlat = (dao[2] - 33) * 1e-2 / 91 / cpl::units::minute();
    dlon = (dao[3] - 33) * 1e-2 / 91 / cpl::units::minute();
  } else {
    return false;
  }

  lat += (lat >= 0 ? dlat : -dlat);
  lon += (lon >= 0 ? dlon : -dlon);
  return true;
}

void test_hide_id(std::ostream& os, 
                  std::string const& id,
                  int const digits,
                  char const repl) {
  os << "hide_id(\"" << id << "\", " << digits << ", '" << repl << "'"
     << ") = \""
     << cpl::ogn::hide_id(id, digits, repl)
     << '"'
     << std::endl;
}


/// Scans s to value according to format and checks that the
/// trailing string immediately follows.
/// The format *must* contain a %n at the end!
/// Doesn't touch value unless the conversion is successful
/// (including the trailing string)!
template<typename T>
bool scan_check_trailing(
    const char* const s,
    const char* const format, 
    const char* const trailing,
    T& ret) {
  assert(std::string(format).find("%n") + 2 == std::strlen(format));
  T value = T();
  int chars_consumed = 0;
  if (1 != std::sscanf(s, format, &value, &chars_consumed)) {
    return false;
  }

  assert(chars_consumed <= static_cast<long>(std::strlen(s)));

  if (0 == std::strcmp(trailing, &s[chars_consumed])) {
    ret = value;
    return true;
  } else {
    return false;
  }
}

} // end anonymous namespace


std::unique_ptr<cpl::util::network::connection> cpl::ogn::connect(
    std::ostream& log,
    const std::string& host,
    const std::string& service,
    const double timeout) {

  log << prio::NOTICE << "Connecting to " << host << ":" << service << std::endl;
  std::unique_ptr<cpl::util::network::connection> ret(
      new cpl::util::network::connection(host, service, timeout));

  log << prio::NOTICE << "Local address: " << ret->local() << std::endl ;
  log << prio::NOTICE << "Peer address: "  << ret->peer () << std::endl ;

  return ret;
}

void cpl::ogn::login(
    std::ostream& log,
    std::ostream& os,
    std::istream& is,
    const std::string& version,
    const std::string& filter,
    const std::string& username) {

  std::string login_string = "user " + username + " pass -1 vers " + version;
  if ("" != filter) {
    login_string += " filter " + filter;
  }

  log << prio::NOTICE << "OGN login string: " << login_string << std::endl;
  os << login_string << std::endl;

  if (!os) {
    log << prio::ERR << "OGN login: connection died" << std::endl;
    throw std::runtime_error("Login failure");
  }

  std::string reply;
  for (int i = 0; i < 2; ++i) {
    cpl::util::getline(is, reply, 200);
    log << prio::NOTICE << "Login result: " << reply << std::endl;
  }

  if (std::string::npos == reply.find("server")) {
    log << prio::ERR << "OGN login: denied" << std::endl;
    throw std::runtime_error("Login failure");
  } else {
    log << prio::NOTICE << "OGN login: OK" << std::endl;
  }

}

cpl::ogn::ddb_handler::~ddb_handler() {
  if (query_thread_active) {
    cpl::util::log::syslogger log("OGN-DDB-QUERY-THREAD-DESTRUCTOR");

    query_thread_active = false;
    log << cpl::util::log::prio::NOTICE
        << "Waiting for DDB query thread to finish..."
        << std::endl;
    query_thread.join();
  }
}

cpl::db::table_statistics
cpl::ogn::get_table_statistics(const cpl::ogn::vehicle_db& vdb) {
  cpl::db::table_statistics ret;
  ret.name = "(unnamed)";
  ret.type = "OGN Device Database";

  ret.size = vdb.size();
  
  // Iterate using ID index
  for (const auto& el : by_id(vdb)) {
    ret.bytes_precise += cpl::util::memory_consumption(el.id);

    const auto& data = el.data;
    ret.bytes_precise +=
        cpl::util::memory_consumption(data.name1);
    ret.bytes_precise +=
        cpl::util::memory_consumption(data.name2);
    ret.bytes_precise +=
        cpl::util::memory_consumption(data.type);
    ret.bytes_precise +=
        cpl::util::memory_consumption(data.tracking);
    ret.bytes_precise +=
        cpl::util::memory_consumption(data.id_type_probably_wrong);
  }

  ret.bytes_estimate = ret.bytes_precise;
  return ret;
}

void cpl::ogn::ddb_handler::set_vdb(
    std::ostream& log,
    cpl::ogn::vehicle_db&& new_vdb) {
  if (new_vdb.size() > 0) {
    std::lock_guard<std::mutex> vdb_lock(vdb_mutex);
    vdb = std::move(new_vdb);
    has_nontrivial_vdb = true;
    log << cpl::util::log::prio::NOTICE
        << "OGN: DDB replaced: " << vdb.size() << " entries" << std::endl;
  } else {
    log << cpl::util::log::prio::NOTICE
        << "OGN: DDB not replaced (empty replacement)"
        << std::endl;
  }
}

void cpl::ogn::ddb_handler::query_thread_function() {
  cpl::util::log::syslogger log("OGN-DDB-QUERY-THREAD");
  log << cpl::util::log::prio::NOTICE
      << "DDB query thread started, interval: "
      << query_interval
      << " seconds" << std::endl;

  while (query_thread_active) {
    set_vdb(log, get_vehicle_database_ddb(log, add_unidentified));

    for (double t = 0; t < query_interval; t += ::DDB_QUERY_SLEEP_INTERVAL) {
      if (not query_thread_active) { return; }
      cpl::util::sleep(::DDB_QUERY_SLEEP_INTERVAL);
    }
  }

  log << cpl::util::log::prio::NOTICE
      << "DDB query thread exiting..."
      << std::endl;
}

cpl::ogn::ddb_handler::ddb_handler(
    std::ostream& log,
    bool const add_unidentified_in,
    double const query_interval_in,
    std::string const& initial_vdb)
: add_unidentified(add_unidentified_in),
  query_interval  (query_interval_in),
  query_thread_active(query_interval > 0),
  has_nontrivial_vdb(false) 
{
  cpl::util::verify(query_interval > ::DDB_QUERY_SLEEP_INTERVAL
      or query_interval <= 0,
      "DDB querying: Query interval must be >= 3s or negative");

  log << prio::NOTICE
      << "OGN: APRS parser instantiated "
      << (query_thread_active ? "with" : "without")
      << " background DDB querying"
      << std::endl;

  if ("" != initial_vdb) {
    log << prio::NOTICE << "OGN: Reading DDB from "
        << initial_vdb
        << std::endl;
    set_vdb(log, cpl::ogn::get_vehicle_database_ddb(log, add_unidentified, initial_vdb));
  }

  if (query_thread_active) {
    query_thread = std::thread{&ddb_handler::query_thread_function, this};
  }
}

std::string cpl::ogn::vehicle_type_to_string(const int type) {
  switch (type) {
    case cpl::ogn::VEHICLE_TYPE_GLIDER     : return ::VEHICLE_DESC_GLIDER     ;
    case cpl::ogn::VEHICLE_TYPE_TOW_PLANE  : return ::VEHICLE_DESC_TOW_PLANE  ;
    case cpl::ogn::VEHICLE_TYPE_POWER_PLANE: return ::VEHICLE_DESC_POWER_PLANE;
    case cpl::ogn::VEHICLE_TYPE_HELICOPTER : return ::VEHICLE_DESC_HELICOPTER ;
    default: return "UNKNOWN";
  }
}

// accepts single vehicle type e.g. "HELI", "PWG",...
int cpl::ogn::parse_vehicle_type(const std::string& type)
{
  if (VEHICLE_DESC_GLIDER == type) {
    return VEHICLE_TYPE_GLIDER;
  }
  if (VEHICLE_DESC_TOW_PLANE == type) {
    return VEHICLE_TYPE_TOW_PLANE;
  }
  if (VEHICLE_DESC_HELICOPTER == type) {
    return VEHICLE_TYPE_HELICOPTER;
  }
  if (VEHICLE_DESC_DROP_PLANE == type) {
      return VEHICLE_TYPE_DROP_PLANE;
  }
  if (VEHICLE_DESC_DELTA == type) {
    return VEHICLE_TYPE_DELTA;
  }
  if (VEHICLE_DESC_PARAGLIDER == type) {
    return VEHICLE_TYPE_PARAGLIDER;
  }
  if (VEHICLE_DESC_POWER_PLANE == type) {
    return VEHICLE_TYPE_POWER_PLANE;
  }
  if (VEHICLE_DESC_JET == type) {
    return VEHICLE_TYPE_JET;
  }
  if (VEHICLE_DESC_UFO == type) {
    return VEHICLE_TYPE_UFO;
  }
  if (VEHICLE_DESC_BALLOON == type) {
    return VEHICLE_TYPE_BALLOON;
  }
  if (VEHICLE_DESC_AIRSHIP == type) {
      return VEHICLE_TYPE_AIRSHIP;
  }
  if (VEHICLE_DESC_UAV == type) {
    return VEHICLE_TYPE_UAV;
  }
  //14 not assigned
  if (VEHICLE_DESC_STATIC == type) {
    return VEHICLE_TYPE_STATIC;
  }

  throw cpl::util::value_error(
      "Invalid aircraft_type string received:" + type);
}

std::set<short> cpl::ogn::vehicle_types_to_set(const std::string& types)
{
  std::set<short> types_s;

  if (types.empty()) {
    return types_s;
  }

  // fill the set
  std::vector<std::string> v;
  cpl::util::split(v, types, "|");
  for (unsigned i=0; i < v.size(); i++) {
    const short type = cpl::ogn::parse_vehicle_type(v[i]);
    types_s.insert(type);
  }
  return types_s;
}

bool cpl::ogn::is_of_vehicle_type(const short vehicle_type, const std::set<short>& types)
{
  auto found = types.find(vehicle_type);
  return types.end() != found;
}

namespace {
  
bool parse_station_status_message(
    const char* const line,
    cpl::ogn::station_info& stat,
    const bool exceptions) {
  int constexpr n_special = 5;
  char special[n_special][31];

  // TODO: Could use strok or similar?
  const char* const format = 
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s";

  const int conversions = std::sscanf(
      line, format,
      special[0],  // v0.2.8.RPI-GPU
      special[1],  // CPU:0.5
      special[2],  // RAM:137.3/969.8MB
      special[3],  // NTP:0.2ms/+1.7ppm
      special[4]); // +47.2C

  if (conversions >= 1) {
    stat.version.software = special[0];
  }

  // PW... stations don't send CPU info etc, just versions
  // The second string is e.g. OGN-R/PilotAware and
  // is ignored.
  if (1 == conversions or 2 == conversions) {
    return true;
  }

  if (conversions < n_special) {
    if (exceptions) {
      cpl::util::throw_parse_error(
          "Expected station version and info");
    } else {
      return false;
    }
  }
  
  // CPU:0.5
  {
    const int res = std::sscanf(special[1], "CPU:%lf", &stat.cpu_load);
    if (1 != res) {
      if (exceptions) {
        cpl::util::throw_parse_error("Failed to parse CPU load");
      } else {
        return false;
      }
    }
  }

  // RAM:137.3/969.8MB
  {
    const int res = std::sscanf(special[2], "RAM:%lf/%lfMB",
        &stat.ram_used_mb, &stat.ram_available_mb);
    if (2 != res) {
      if (exceptions) {
        cpl::util::throw_parse_error("Failed to parse RAM used/available");
      } else {
        return false;
      }
    }
  }

  // NTP:0.2ms/+1.7ppm
  {
    const int res = std::sscanf(special[3], "NTP:%lfms/%lfppm",
        &stat.ntp_difference, &stat.ntp_ppm);
    if (2 != res) {
      if (exceptions) {
        cpl::util::throw_parse_error("Failed to parse NTP information");
      } else {
        return false;
      }
    } else {
      // Convert to [s]
      stat.ntp_difference *= 1e-3;
    }
  }

  // +47.2C
  {
    const int res = std::sscanf(special[4], "%lfC", &stat.temperature);
    if (1 != res) {
      if (exceptions) {
        cpl::util::throw_parse_error("Failed to parse temperature"); 
      } else {
        return false;
      }
    }
  }

  return true;
}

} // anonymous namespace

void cpl::ogn::update(
          cpl::ogn::station_info& lhs,
    const cpl::ogn::station_info& rhs) {
  // Network, time is present in both variants
  lhs.network = rhs.network;
  lhs.pt.time = rhs.pt.time;

  if (cpl::ogn::is_status_info(rhs)) {
    lhs.cpu_load         = rhs.cpu_load        ;
    lhs.ram_used_mb      = rhs.ram_used_mb     ;
    lhs.ram_available_mb = rhs.ram_available_mb;

    lhs.ntp_difference   = rhs.ntp_difference  ;
    lhs.ntp_ppm          = rhs.ntp_ppm         ;

    lhs.temperature      = rhs.temperature     ;

    lhs.version          = rhs.version         ;
  } else {
    lhs.pt = rhs.pt;
  }
}

bool cpl::ogn::parse_aprs_station(
    const std::string& line, 
    cpl::ogn::station_info_and_name& stat,
    const double utc,
    const bool exceptions,
    const int start_character) {
  assert(start_character >= 0);
  assert(start_character < static_cast<long>(line.size()));

  char station_v [41] = "";
  char lon_v[30] = "";
  double alt_ft = 0;

  char network_v [41] = "";

  long hhmmss = 0;

  int chars_consumed_including_time = 0;

  char slash_or_greater[2] = "";
  char NS[2] = "";
  char EW[2] = "";

  // Normal, special conversions
  // Notice: Beginning with 0.2.6, no more 'special' conversions,
  // see format with ":>" instead
  int constexpr n_normal  = 9;
  int constexpr n_special = 5;
  char special[n_special][31];

  // TODO: 'special' conversion in this string no longer a factor
  // for newer station software versions (3/2021).
  const char* const format = 
      "%40[^ >]" // station name
      ">%*[^,],TCPIP*,qAC,"
      "%40[^:]" // network? (seen: GLIDERN1, GLIDERN2)
      ":"
      "%1[/>]"  // slash_or_greater ":/": We have a lat/lon, ":>" Status info, no lat/lon
      "%ld"     // HHMMSSh
      "h"       // zulu time
      "%n"      // characters consumed up to here
      "%lf"     // latitude
      "%1[NS]"  // north/south
      "I"       // It's there, why?
      "%20[0-9.]"  // lon as string
      "%1[EW]"     // east/west
      "%*[^A]"  // cse/spd, not parsed for stations that are normally, well,
                // stationary
      "A=%lf "  // altitude [ft]
      "%30s "   // Specials: CPU, RAM, vx.y.z, NTP, each up to 30 characters
      "%30s "
      "%30s "
      "%30s "
      "%30s"
      // TODO: etc: RF:+40+2.7ppm/+0.8dB
      // TODO: As of 0.2.6, the 'specials' appear for :> messages.
      //       For :/ messages, we have 'Key: Value' pairs, e.g.
      //   Webcam: http://www.vueloavela.cl or
      //   Contact: web@master.com
      //   See DEAD_CODE below
  ;

  const int conversions = std::sscanf(
      line.c_str() + start_character, format, 
      station_v,
      network_v,
      slash_or_greater,
      &hhmmss,
      &chars_consumed_including_time,
      &stat.second.pt.lat,
      NS,
      lon_v,
      EW,
      &alt_ft,
      special[0],
      special[1],
      special[2],
      special[3],
      special[4]);

  if (n_normal <= conversions) {
    // This must be a ":/"
    if ('/' != slash_or_greater[0]) {
      if (exceptions) {
        cpl::util::throw_parse_error(
            "Expected slash or greater sign after network");
      } else {
        return false;
      }
    }
    if (not my_double_cast(lon_v, stat.second.pt.lon)) {
      if (exceptions) {
        cpl::util::throw_parse_error(
            "Failed to parse longitude");
      } else {
        return false;
      }
    }

    stat.first = station_v;
    stat.second.network = network_v;
    stat.second.pt.time = adapt_utc(hhmmss_to_seconds(hhmmss), utc);

    set_latlon(NS, EW, stat.second.pt.lat, stat.second.pt.lon);
    stat.second.pt.alt = alt_ft * cpl::units::foot();

    return true;
  } else {
    // If we have ":>" and the first 4, we're happy but 
    // signal nothing parsed by setting name to ""
    if (4 == conversions && '>' == slash_or_greater[0]) {
      stat.first = station_v;
      stat.second.network = network_v;
      stat.second.pt.time = adapt_utc(hhmmss_to_seconds(hhmmss), utc);

      stat.second.version = cpl::ogn::versions();

      // Ensure that parsing stopped at "hhmmssh v0.x.y"
      always_assert(line.at(start_character + chars_consumed_including_time) == ' ');
      const auto ret = ::parse_station_status_message(
          line.c_str() + start_character + chars_consumed_including_time + 1,
          stat.second,
          exceptions);
      always_assert(cpl::ogn::is_status_info(stat.second));
      return ret;
    } else {
      if (exceptions) {
        cpl::util::throw_parse_error(
          "Some conversions failed or invalid character after network");
      }
      return false;
    }
  }
}

std::string cpl::ogn::qualified_id(std::string const& id, short id_type) {
  switch (id_type) {
    case cpl::ogn::ID_TYPE_RANDOM: return "random:"  + id;
    case cpl::ogn::ID_TYPE_FLARM : return "flarm:"   + id;
    case cpl::ogn::ID_TYPE_ICAO  : return "icao:"    + id;
    case cpl::ogn::ID_TYPE_OGN   : return "ogn:"     + id;

    case cpl::ogn::ID_TYPE_PILOT_AWARE: return "pilotaware:" + id;
    case cpl::ogn::ID_TYPE_FLYMASTER  : return "flymaster:"  + id;
    case cpl::ogn::ID_TYPE_FANET      : return "fanet:"      + id;
    case cpl::ogn::ID_TYPE_NAVITER    : return "naviter:"    + id;
    case cpl::ogn::ID_TYPE_SPOT       : return "spot:"       + id;

    default: return "unknown:" + id;
  }
}

short cpl::ogn::id_type(
    const std::string& station_id,
    const cpl::ogn::aprs_info&) {
  if (boost::starts_with(station_id, "PAW")) {
    return cpl::ogn::ID_TYPE_PILOT_AWARE;
  }

  if (boost::starts_with(station_id, "FMT")) {
    return cpl::ogn::ID_TYPE_FLYMASTER;
  }

  if (boost::starts_with(station_id, "FNT")) {
    return cpl::ogn::ID_TYPE_FANET;
  }

  return cpl::ogn::ID_TYPE_UNKNOWN;
}

std::string cpl::ogn::unqualified_id(std::string const& id) {
  auto const colon = id.find(':');
  if (std::string::npos == colon) {
    return id;
  } else {
    return id.substr(colon + 1, std::string::npos);
  }
}

std::string cpl::ogn::id_type(std::string const& id) {
  auto const colon = id.find(':');
  if (std::string::npos == colon) {
    return "unknown";
  } else {
    return id.substr(0, colon);
  }
}

std::string cpl::ogn::hide_id(
    std::string const& id,
    int const n,
    char const replacement) {
  assert(n >= 0);
  auto ret = id;
  auto const colon = id.find(':');
  if (std::string::npos == colon) {
    return id;
  } else {
    for (std::string::size_type i = 1; 
         i <= static_cast<std::string::size_type>(n) && id.size() > colon + i;
         ++i) {
      // id.size() > id.size() - i > colon >= 0
      ret[id.size() - i] = replacement;
    }
  }
  return ret;
}

std::ostream& cpl::ogn::operator<<(
    std::ostream& os, cpl::ogn::station_info const& stat) {
  os <<        stat.version.software
     << " " << stat.version.hardware
     << " " << stat.network
     << " " << stat.pt
     << " " << stat.cpu_load
     << " " << stat.ram_used_mb
     << " " << stat.ram_available_mb
     << " " << stat.ntp_difference
     << " " << stat.ntp_ppm
     << " " << stat.temperature
  ;
  return os;
}

std::ostream& cpl::ogn::operator<<(
    std::ostream& os, cpl::ogn::aircraft_rx_info const& acft) {
  os <<        acft.id_type
     << " " << acft.vehicle_type
     << " " << acft.stealth
     // << " " << acft.data.process // always 1
     << " " << acft.data.tracking
     << " " << acft.data.identify
     << " " << acft.data.name1
     << " " << acft.ver.hardware
     << " " << acft.ver.software
     << " " << static_cast<cpl::gnss::position_time const&>(acft.pta)
     << " " << acft.pta.horizontal_accuracy
     << " " << acft.pta.vertical_accuracy
     << " " << acft.mot.course
     << " " << acft.mot.speed
     << " " << acft.mot.vertical_speed
     << " " << acft.mot.turnrate
     << " " << acft.baro_alt
     << " " << acft.rx
  ;
  return os;
}

std::ostream& cpl::ogn::operator<<(
    std::ostream& os, cpl::ogn::thermal const& th) {
  os << "THERMAL "
     << th.pt
     << ' ' << th.climbrate
  ;
  return os;
}

char const* cpl::ogn::thermal_format_comment() {
  return "# THERMAL time lat lon alt climbrate";
}

std::ostream& cpl::ogn::operator<<(
    std::ostream& os, cpl::ogn::rx_info const& rx) {
  os <<        rx.received_by
     << " " << rx.aprs.tocall
     << " " << rx.is_relayed
     << " " << rx.aprs.relay
     << " " << rx.radio_id
     << " " << rx.rssi
     << " " << rx.frequency_deviation
     << " " << rx.errors
  ;
  return os;
}

// Method: Search for qAS.  If it's 3 entries before that, we have a relay,
// otherwise we don't
bool cpl::ogn::parse_qas_construct(
    const std::string& s, cpl::ogn::aprs_info& q) {
  
  cpl::util::splitter spl(s, ',');

  if (!spl.get_next(q.tocall)) {
    return false;
  }

  std::string qAS_or_relay;
  int relay_count = 0;
  q.relay = std::string();
  while (spl.get_next(qAS_or_relay) && "qAS" != qAS_or_relay) {
    q.relay = qAS_or_relay;
    ++relay_count;
  }

  // Currently we support only one hop
  if (relay_count > 1) {
    return false;
  }

  if (!spl.get_next(q.from)) {
    return false;
  } 

  return true;
}
 
// Parses APRS lines containing OGN targets.
// If a vehicle_db is installed, fills in data from there.
// See http://wiki.glidernet.org/wiki:subscribe-to-ogn-data
bool cpl::ogn::aprs_parser::parse_aprs_aircraft(
    const std::string& line, 
    cpl::ogn::aircraft_rx_info_and_name& acft,
    double const utc,
    const bool exceptions,
    const int start_character) {
  assert(start_character >= 0);
  assert(start_character < static_cast<long>(line.size()));

  unsigned id_and_type = 0;
  char id_v[8] = "";

  long hhmmss = 0;

  char hhmmss_or_ddhhmm[2] = "";

  double climb_rate_fpm = 0, turn_rate_rot = 0;
  double alt_ft = 0;
  double baro_alt_fl = 0;

  char cse_spd[11] = "";

  // This is now FLRXXXXXX or OGNXXXXXX or PAWXXXXXX or ICAXXXXXX.
  // See handling ID types further down depending on the first three
  // letters of station_id_v, id_and_type or APRS routing names.
  char station_id_v[41] = "";
  char q_construct_v[81] = "";
  char slash_or_greater[2] = "";
  char lon_v[21] = "";
  char NS[2] = "";
  char EW[2] = "";

  // Normal, special conversions
  int constexpr n_normal  = 11;
  int constexpr n_special = 12;
  char special[n_special][31];

  // qAR / qAS: See 'q Construct', http://www.aprs-is.net/q.aspx
  // It's either qAS,<relay> or qAR for directly received packets
  // OGN only uses qAS, no qAR for stations (?)
  // q construct: TOCALL,[(relay)*],qAS,FROM
  // See struct q_construct in ogn.h
  const char* const format = 
      "%40[^ >]"   // station_id_v
      ">"
      "%80[^:]"   // q_construct_v
      ":"
      "%1[/>]"    // slash_or_greater; ':/' or ':>'.  Only ':/' is supported.
                  // The second results in an empty name.
      "%ld"      // hhmmss
      "%1[hz]"    // h or z / HHMMSS or DDHHMM
                  // TODO: Support the 'z', although it should be rare
                  // Pawel 5/2019 (skype): "After APRS specification, the "z" time 
                  // is DDHHMMz where DD is day-of-the-month"
                  // "It does happen sometimes... when the station looses internet 
                  // conenction and then it comes back"
      "%lf"       // latitude
      "%1[NS]"    // north/south
      "%*[/\\]"   // separator, may be slash or backslash (!)
      "%20[0-9.]"
      "%1[EW]"    // east/west
      "%*c"       // z, ', ... (movement indicator?)
      "%10[^A]"  // course/speed, either "CCC/SSS/" or just "/" if not moving
      "A=%lf "   // altitude [ft]
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s "
      "%30s"
  ;

  const int conversions = std::sscanf(
      line.c_str() + start_character, format,
      station_id_v,
      q_construct_v,
      slash_or_greater,
      &hhmmss,
      hhmmss_or_ddhhmm,
      &acft.second.pta.lat,
      NS,
      lon_v,
      EW,
      cse_spd,
      &alt_ft,
      special[0],
      special[1],
      special[2],
      special[3],
      special[4],
      special[5],
      special[6],
      special[7],
      special[8],
      special[9],
      special[10],
      special[11]);

  if (conversions < 4) {
    if (exceptions) {
      cpl::util::throw_parse_error(
          "Failed to parse basic info: "
          "Number of successful conversions: " + std::to_string(conversions));
    } else {
      return false;
    }
  }

  if (not parse_qas_construct(q_construct_v, acft.second.rx.aprs)) {
    // Roll back
    acft.second.rx.aprs = ::cpl::ogn::aprs_info();
    if (exceptions) {
      cpl::util::throw_parse_error(std::string("q construct: ") + q_construct_v);
    } else {
      return false;
    }
  }

  // Ignore ':>' lines with status info.
  if ('>' == slash_or_greater[0]) {
    acft.first = "";
    return true;
  }

  if (conversions < n_normal) {
    if (exceptions) {
      cpl::util::throw_parse_error(
          "Failed to parse position: "
          "Number of successful conversions: " + std::to_string(conversions));
    } else {
      return false;
    }
  }

  // Ignore 'z' for time (DDHHMM), should be rare
  if ('z' == hhmmss_or_ddhhmm[0]) {
    acft.first = "";
    return true;
  }

  assert('h' == hhmmss_or_ddhhmm[0]);

  // TODO: This needs to be more flexible.  We should check each field
  // for its content and assign accordingly.  For now we assume
  // a certain order (implicit in the scanf() sequence below), and
  // some elements may be missing.
  int const special_converted = conversions - n_normal;

  acft.second.rx.is_relayed = not acft.second.rx.aprs.relay.empty();
  int const min_special_converted = 1;
  if (special_converted < min_special_converted) {
    if (exceptions) {
      util::throw_parse_error(
            "Expected at least " + std::to_string(min_special_converted)
          + " parameter(s) after basic info, found "
          + std::to_string(special_converted));
    } else {
      return false;
    }
  }
  {
    // "sub-parser" for cse/speed
    int course = 0, speed_kt = 0;

    if ('/' == cse_spd[0] ||
        (   '/' == cse_spd[3]
         && 8   == std::strlen(cse_spd)
         && 2   == std::sscanf(cse_spd, "%d/%d/", &course, &speed_kt))) {
      acft.second.mot.course = course;
      // TODO: Is this really in knots?
      acft.second.mot.speed  = speed_kt * cpl::units::knot();
    } else {
      if (exceptions) {
        util::throw_parse_error(std::string("Course/speed: ") + cse_spd);
      } else {
        return false;
      }
    }
  }

  acft.second.rx.received_by = acft.second.rx.aprs.from;
  acft.second.data.name1 = "-";
  acft.second.pta.time = adapt_utc(hhmmss_to_seconds(hhmmss), utc);

  if (!my_double_cast(lon_v, acft.second.pta.lon)) {
    if (exceptions) {
      util::throw_parse_error(std::string("Longitude: ") + lon_v);
    } else {
      return false;
    }
  }

  set_latlon(NS, EW, acft.second.pta.lat, acft.second.pta.lon);
  acft.second.pta.alt = alt_ft * cpl::units::foot();

  if (acft.second.pta.alt > MAX_PLAUSIBLE_ALTITUDE) {
    if (exceptions) {
      util::throw_parse_error("Implausible altitude: " 
            + std::to_string(acft.second.pta.alt));
    } else {
      return false;
    }
  }

  int shift = 0;

  if ('!' == special[0][0]) {
    if (not set_latlon_dao(special[0], acft.second.pta.lat, acft.second.pta.lon)) {
      if (exceptions) {
        util::throw_parse_error(std::string("DAO construct: ") + special[0]);
      } else {
        return false;
      }
    }
    ++shift;
  }

  bool         id_parsed = false;
  bool climb_rate_parsed = false;
  bool  turn_rate_parsed = false;

  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  if (2 == std::sscanf(special[shift], "id%2x%7s", &id_and_type, id_v)) {
    id_parsed = true;
    ++shift;
    if (6 != std::strlen(id_v)) {
      if (exceptions) {
        util::throw_parse_error(
            std::string("ID: Expected 6 characters: ") + id_v);
      } else {
        return false;
      }
    }
  }

  // Vertical speed
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  climb_rate_parsed = ::scan_check_trailing(special[shift], "%lf%n", "fpm", climb_rate_fpm);
  shift += climb_rate_parsed;

  // Turn rate
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  turn_rate_parsed = ::scan_check_trailing(special[shift], "%lf%n", "rot", turn_rate_rot);
  shift += turn_rate_parsed;

  // FL (flight level).  May be missing.
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  if (1 == std::sscanf(special[shift], "FL%lf", &baro_alt_fl)) {
    ++shift;
    acft.second.baro_alt = baro_alt_fl * cpl::units::flight_level();
  }

  // RSSI.  May be missing.
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  shift += ::scan_check_trailing(special[shift], "%lf%n", "dB", acft.second.rx.rssi);

  // 0e, 1e, 2e etc. (errors).  May be missing.
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  shift += ::scan_check_trailing(special[shift], "%hd%n", "e", acft.second.rx.errors);

  // Frequency deviation
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  shift += ::scan_check_trailing(special[shift], "%lf%n", "kHz", acft.second.rx.frequency_deviation);

  // GPS accuracy
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  if (2 == std::sscanf(special[shift], "gps%lfx%lf", 
                       &acft.second.pta.horizontal_accuracy,
                       &acft.second.pta.vertical_accuracy)) {
    // horizontal/vertical accuracy
    // GPS accuracy may be missing for OGN trackers
    ++shift;
  }

  // Software version
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  if ('s' == special[shift][0]) {
    acft.second.ver.software = special[shift] + 1;
    ++shift;
  }

  // Hardware version
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  // Parse h6.xx, but not hearXXXX (old versions had that)
  if ('h' == special[shift][0] && 'e' != special[shift][1]) {
    acft.second.ver.hardware = special[shift] + 1;
    ++shift;
  }

  // Radio ID
  if (shift >= special_converted) { goto postprocess; }
  assert(shift < special_converted);
  if ('r' == special[shift][0]) {
    acft.second.rx.radio_id = special[shift] + 1;
    ++shift;
  }

  // Post processing of values (units etc.)
postprocess:

  if (id_parsed) {
    // TODO: Check here whether ID from station_id_v and from id_and_type
    // agree.

    // STttttaa
    // stealth mode S, no-tracking flag T, aircraft type tttt, address type aa
    acft.second.id_type      =   id_and_type       & 0x3  ;
    acft.second.vehicle_type =  (id_and_type >> 2) & 0xf  ;
    acft.second.process      = !(id_and_type       & 0x40);
    acft.second.stealth      =   id_and_type       & 0x80 ;
    // acft.second.data.track and acft.second.data.identify are filled in
    // by caller.

    // NAVITER messes with the data.  Until we know what's going on,
    // be careful and override ID type.
    // Let's hope that the below are really mutually exclusive...
    // E.g.
    // APRS_AIRCRAFT ICAFOOBAR>APRS,qAS,NAVITER2:/100646h4416.94N/00555.79E'000/000/A=001791 !W11! id06FOOBAR +000fpm +0.0rot
    // APRS_AIRCRAFT ICAFOOBAR>OGFLR,qAS,LFNS:/100659h4416.94N/00555.79E'153/000/A=001762 !W00! id05FOOBAR +000fpm +0.0rot 23.8dB -14.1kHz gps1x2
    // According to OGFLR, id05 -> ICAO, according to NAVITER2 -> FLARM which is BS.
    // As of 7/2024, we seem to have NAVITER and NAVITER2.
    if        (boost::starts_with(acft.second.rx.aprs.from, "NAVITER")) {
      acft.second.id_type = cpl::ogn::ID_TYPE_NAVITER;
    } else if ("SPOT" == acft.second.rx.aprs.from) {
      acft.second.id_type = cpl::ogn::ID_TYPE_SPOT;
    } else if ("OGNFNT" == acft.second.rx.aprs.tocall) {
      // Similar with FANET, but here we look at the TOCALL.  FANET
      // itself would claim FLARM...
      acft.second.id_type = cpl::ogn::ID_TYPE_FANET;
    } else if (boost::starts_with(station_id_v, "PAW")) {
      // For PilotAware, we need to check whether the station ID starts with PAW.
      // Override ID type in that case, otherwise it becomes OGN.  See
      // G-1234 test case in KTrax.
      acft.second.id_type = cpl::ogn::ID_TYPE_PILOT_AWARE;
    }

    // Primary key ID: 'first' element of the pair.
    acft.first = qualified_id(id_v, acft.second.id_type);
  } else {
    const std::string station_id = station_id_v;

    acft.second.id_type = cpl::ogn::id_type(station_id, acft.second.rx.aprs);
    acft.first = qualified_id(
        station_id.substr(3, std::string::npos), acft.second.id_type);

    if (cpl::ogn::ID_TYPE_FLYMASTER == acft.second.id_type) {
      acft.second.vehicle_type = cpl::ogn::VEHICLE_TYPE_PARAGLIDER;
    } else {
      acft.second.vehicle_type = cpl::ogn::VEHICLE_TYPE_UNKNOWN;
    }

    acft.second.stealth = false;
    acft.second.process = true;
  }

  if (climb_rate_parsed) {
    acft.second.mot.vertical_speed =
      climb_rate_fpm * cpl::units::foot() / cpl::units::minute();
  } else {
    acft.second.mot.vertical_speed = 0;
  }

  if (turn_rate_parsed) {
    // http://wiki.glidernet.org/wiki:subscribe-to-ogn-data
    // OGN doc is unclear here:
    // "1rot is the standard aircraft rotation rate of 1 half-turn per two
    // minutes.".  We assume 1rot indicates a standard procedure turn rate
    // which is 3 degrees/second.
    // Pawel June 22, 2015: Standard turn 180deg/min == 3deg/sec.
    acft.second.mot.turnrate = 3 * turn_rate_rot;
  } else {
    acft.second.mot.turnrate = 0;
  }

  apply(acft);

  return true;
}

void cpl::ogn::ddb_handler::apply(
    cpl::ogn::aircraft_rx_info_and_name& acft) const {

  std::lock_guard<std::mutex> lock(vdb_mutex);
  if (has_nontrivial_vdb) {
    auto const it = vdb.find(unqualified_id(acft.first));
    if (vdb.end() != it) {
      acft.second.data = it->data;
    }
  }

}

long cpl::ogn::ddb_handler::write_names_json(
    std::ostream& oss,
    const int which) const {
  oss << "[\n";
  cpl::util::verify_bounds(which, "which parameter", 1, 3);
  auto const extract = 3 == which ? 
    cpl::ogn::extract_id : (1 == which ? cpl::ogn::extract_name1 
                                       : cpl::ogn::extract_name2);

  std::lock_guard<std::mutex> lock(vdb_mutex);

  long ret = 0;
  for (auto it  = by_id(vdb).begin(); 
            it != by_id(vdb).end  (); /* no increment */) {
    oss << '"' << extract(*it) << '"';
    ++ret;
    ++it;
    if (by_id(vdb).end() == it) {
      break;
    }
    oss << ",\n";
  }
  oss << ']';
  return ret;
}

cpl::ogn::vehicle_data cpl::ogn::ddb_handler::lookup(
    std::string const& id,
    const bool throw_if_not_found) const {
  std::lock_guard<std::mutex> lock(vdb_mutex);
  if (!has_nontrivial_vdb) {
    if (throw_if_not_found) {
      throw std::runtime_error("OGN: DDB lookup: DB not loaded, id: " + id);
    } else {
      return cpl::ogn::vehicle_data();
    }
  }

  auto const it = by_id(vdb).find(unqualified_id(id));
  if (vdb.end() == it) {
    if (throw_if_not_found) {
      throw std::runtime_error("OGN: DDB entry not found for " + id);
    } else {
      return cpl::ogn::vehicle_data();
    }
  }

  return it->data;
}

std::vector<cpl::ogn::vehicle_data_and_id>
cpl::ogn::lookup_by_name1(
    cpl::ogn::vehicle_db const& vdb, std::string const& name1) {
  std::vector<cpl::ogn::vehicle_data_and_id> ret;
  if (cpl::util::is_trivial_string(cpl::util::canonical(name1))) {
    return ret;
  }
  auto const er = by_name1(vdb).equal_range(name1);
  std::copy(er.first, er.second, std::back_inserter(ret));
  return ret;
}

std::vector<cpl::ogn::vehicle_data_and_id>
cpl::ogn::lookup_by_name2(
    cpl::ogn::vehicle_db const& vdb, std::string const& name2) {
  std::vector<cpl::ogn::vehicle_data_and_id> ret;
  if (cpl::util::is_trivial_string(cpl::util::canonical(name2))) {
    return ret;
  }
  auto const er = by_name2(vdb).equal_range(name2);
  std::copy(er.first, er.second, std::back_inserter(ret));
  return ret;
}

std::vector<cpl::ogn::vehicle_data_and_id>
cpl::ogn::lookup_by_canonical_name1(
    cpl::ogn::vehicle_db const& vdb, std::string const& name1) {
  std::vector<cpl::ogn::vehicle_data_and_id> ret;
  const auto cname1 = cpl::util::canonical(name1);
  if (cpl::util::is_trivial_string(cname1)) {
    return ret;
  }
  auto const er = by_canonical_name1(vdb).equal_range(cname1);
  std::copy(er.first, er.second, std::back_inserter(ret));
  return ret;
}

std::vector<cpl::ogn::vehicle_data_and_id>
cpl::ogn::ddb_handler::lookup_by_name1(std::string const& name1) const {
  std::lock_guard<std::mutex> lock(vdb_mutex);
  return cpl::ogn::lookup_by_name1(vdb, name1);
}

std::vector<cpl::ogn::vehicle_data_and_id>
cpl::ogn::ddb_handler::lookup_by_name2(std::string const& name2) const {
  std::lock_guard<std::mutex> lock(vdb_mutex);
  return cpl::ogn::lookup_by_name2(vdb, name2);
}

std::vector<cpl::ogn::vehicle_data_and_id>
cpl::ogn::ddb_handler::lookup_by_canonical_name1(std::string const& name1) const {
  std::lock_guard<std::mutex> lock(vdb_mutex);
  return cpl::ogn::lookup_by_canonical_name1(vdb, name1);
}

// DDB functions

bool parse_bool(std::string const& s, std::string const& loc) {
  cpl::util::verify("Y" == s || "N" == s,
                    loc + "invalid flag (must be 'Y' or 'N')");
  return "Y" == s;
}

cpl::ogn::vehicle_data_and_id parse_ddb_entry(cpl::util::lexer& lex) {
  cpl::util::expect(lex, cpl::util::STRING);
  auto const id_type_string = lex.string_value();
  cpl::util::verify(1 == id_type_string.size(), 
                    lex.location() + "invalid ID type");

  short id_type;
  switch (id_type_string[0]) {
    case 'F': id_type = cpl::ogn::ID_TYPE_FLARM; break;
    case 'I': id_type = cpl::ogn::ID_TYPE_ICAO ; break;
    case 'O': id_type = cpl::ogn::ID_TYPE_OGN  ; break;
    default : id_type = 0;
              cpl::util::verify(false,
                                lex.location() + "ID type must be O, I or F");
  }

  cpl::util::expect(lex, cpl::util::COMMA);

  cpl::util::expect(lex, cpl::util::STRING);
  auto const id = lex.string_value();
  cpl::util::verify(6 == id.size(), 
                    lex.location() + "invalid ID size (must be 6 digits)");

  cpl::util::expect(lex, cpl::util::COMMA);

  cpl::util::expect(lex, cpl::util::STRING);
  auto type = lex.string_value();
  boost::algorithm::trim(type);
  cpl::util::verify(type.size() <= 40, 
                    lex.location() + "invalid type (must be <= 40 characters)");

  cpl::util::expect(lex, cpl::util::COMMA);

  cpl::util::expect(lex, cpl::util::STRING);
  auto callsign = lex.string_value();
  boost::algorithm::trim(callsign);
  cpl::util::verify(callsign.size() <= 10, 
                    lex.location() 
                    + "invalid callsign (must be <= 10 characters)");

  cpl::util::expect(lex, cpl::util::COMMA);

  cpl::util::expect(lex, cpl::util::STRING);
  auto cn = lex.string_value();
  boost::algorithm::trim(cn);
  cpl::util::verify(cn.size() <= 4,
                    lex.location() 
                    + "invalid competition number (must be <= 4 characters)");

  cpl::util::expect(lex, cpl::util::COMMA);

  cpl::util::expect(lex, cpl::util::STRING);
  auto const tracking = parse_bool(lex.string_value(), lex.location());

  cpl::util::expect(lex, cpl::util::COMMA);

  cpl::util::expect(lex, cpl::util::STRING);
  auto const identify = parse_bool(lex.string_value(), lex.location());

  // Parsing OK, now post-process data
  std::replace(callsign.begin(), callsign.end(), ' ', '_');
  cpl::util::toupper(callsign);
  cpl::util::verify_alnum(callsign, cpl::util::allowed_characters_4());

  std::replace(cn      .begin(), cn      .end(), ' ', '_');
  cpl::util::toupper(cn);
  cpl::util::verify_alnum(cn, cpl::util::allowed_characters_4());

  // Make sure that we don't disclose anything if identify is 'N'.
  // As of 5/2017, ddb already seems to ensure that, but you
  // never know.
  if (not identify) {
    callsign = "-";
    cn       = "-";
  } else {
    if (callsign.empty()) {
      callsign = "-";
      // Special case: Use 'hidden' for CN if callsign *and* CN are
      // empty, but identify is allowed.  This allows client code
      // to publish the FLARM ID in this case.
      if (cn.empty()) {
        cn = "(hidden)";
      }
    }
    if (cn.empty()) {
      cn = "-";
    }
  }

  // Use unqualified ID.  This is a primary key in the DDB
  // and users regularly get the ID type wrong (called
  // 'Device type' in the UI as of July, 2015).
  cpl::ogn::vehicle_data_and_id ret;
  ret.id = id;
  ret.data = 
      cpl::ogn::vehicle_data{callsign, cn, type, tracking, identify, id_type};
  return ret;
}

cpl::ogn::vehicle_db
cpl::ogn::get_vehicle_database_ddb(
    std::ostream& sl, const bool add_unidentified, std::string const& url) {
  cpl::ogn::vehicle_db ret;
  
  try {
    sl << prio::NOTICE
       << "DDB: Reading from " << url
       << "; Adding unidentified entries: "
       << add_unidentified
       << std::endl;
    long n_parsed = 0;
    long n_unidentified = 0;
    std::ifstream ifs;
    std::istringstream iss;
    std::istream* is = NULL;

    if (0 == url.find("http://")) {
      std::ostringstream oss;
      cpl::http::wget(sl, oss, url);
      iss = std::istringstream{oss.str()};
      is = &iss;
    } else {
      ifs.open(url);
      if (!ifs) {
        throw std::runtime_error("couldn't open " + url);
      }
      is = &ifs;
    }
    always_assert(is != NULL);

    cpl::util::lexer_style_t const ddb_style{ 
      cpl::util::hash_comments, cpl::util::single_quote};

    cpl::util::lexer lex{*is, url, ddb_style};

    while (cpl::util::END != lex.peek_token()) {
      cpl::ogn::vehicle_data_and_id ent;
      try {
        ent = parse_ddb_entry(lex);
        ++n_parsed;
        const bool has_id = cpl::ogn::has_identification(ent.data);
        if (not has_id) {
          ++n_unidentified;
        }
        // Add unidentified entries only if explicitly requested!
        if (has_id or add_unidentified) {
          by_id(ret).insert(ent);
        }
      } catch (cpl::util::value_error const& e) {
        // value_error is recoverable, we just discard this entry
        // and continue parsing
        sl << prio::WARNING
           << "DDB: Couldn't parse record: " << e.what() << std::endl;
      }
    }
    sl << prio::NOTICE
       << "DDB: Parsed " << n_parsed << " record(s) from " << url
       << std::endl;
    if (add_unidentified) {
      sl << prio::NOTICE
         << "DDB: Added " << n_unidentified << " record(s) without identification"
         << std::endl;
    } else {
      sl << prio::NOTICE
         << "DDB: Skipped " << n_unidentified << " record(s) without identification"
         << std::endl;
    }
  } catch (std::exception const& e) {
    sl << prio::ERR
       << "Failed to parse DDB from " << url << ": "
       << e.what()
       << std::endl;
  }
  return ret;
}

cpl::ogn::thermal_detector_params::thermal_detector_params(
    int const method)
: method(method) {
  validate();
}


void cpl::ogn::thermal_detector_params::validate() {
  cpl::util::verify(0 <= method && method <= 2,
      "thermal detector method must be 0, 1 or 2");
}

cpl::ogn::thermal_detector_params::thermal_detector_params()
: thermal_detector_params(2) {}

cpl::ogn::thermal_detector_params
cpl::ogn::thermal_detector_params_from_registry(
    cpl::util::registry const& reg,
    thermal_detector_params const& defaults) {
  thermal_detector_params ret;

  ret.method = 
      reg.get_default("method", static_cast<long>(defaults.method));
  ret.dot_size = 
      reg.get_default("dot_size", static_cast<long>(defaults.dot_size));
  ret.max_time_delta = 
      reg.get_default("max_time_delta", defaults.max_time_delta);
  ret.max_speed = 
      reg.get_default("max_speed", defaults.max_speed);
  ret.min_turnrate_glider = 
      reg.get_default("min_turnrate_glider", defaults.min_turnrate_glider);
  ret.min_climbrate = 
       reg.get_default("min_climbrate", defaults.min_climbrate);

  ret.validate();
  return ret;
}


cpl::ogn::thermal cpl::ogn::detect_thermal(
    cpl::ogn::thermal_detector_params const& params,
    cpl::ogn::aircraft_rx_info const& rx) {
  cpl::ogn::thermal ret;

  if (!valid(rx.pta)) {
    return ret;
  }

  if (cpl::ogn::VEHICLE_TYPE_GLIDER == rx.vehicle_type) {
    if (   rx.mot.speed <= params.max_speed
        && rx.mot.turnrate >= params.min_turnrate_glider
        && rx.mot.vertical_speed >= params.min_climbrate) {
      ret.pt        = rx.pta;
      ret.climbrate = rx.mot.vertical_speed;
    }
    return ret;
  }

  if (   cpl::ogn::VEHICLE_TYPE_DELTA == rx.vehicle_type
      || cpl::ogn::VEHICLE_TYPE_PARAGLIDER == rx.vehicle_type) {
    // Don't consider turn rate for PG and deltas
    if (   rx.mot.speed <= params.max_speed
        && rx.mot.vertical_speed >= params.min_climbrate) {
      ret.pt        = rx.pta;
      ret.climbrate = rx.mot.vertical_speed;
    }
    return ret;
  }

  // None of the above, no thermal
  return ret;
}

cpl::ogn::thermal cpl::ogn::detect_thermal(
    cpl::ogn::thermal_detector_params const& params,
    cpl::ogn::aircraft_rx_info const& current,
    cpl::ogn::aircraft_rx_info const* const previous) {

  if (1 == params.method || NULL == previous) {
    return cpl::ogn::detect_thermal(params, current);
  }

  cpl::ogn::thermal ret;
  if (2 != params.method) {
    return ret;
  }

  if (!(   cpl::ogn::VEHICLE_TYPE_GLIDER     == current.vehicle_type
        || cpl::ogn::VEHICLE_TYPE_DELTA      == current.vehicle_type
        || cpl::ogn::VEHICLE_TYPE_PARAGLIDER == current.vehicle_type)) {
    return ret;
  }

  if (!(valid(current.pta) && valid(previous->pta))) {
    return ret;
  }

  double const dt = current.pta.time - previous->pta.time;
  // std::cout << "dt: " << dt << std::endl;
  if (dt <= 0.1 || dt >= params.max_time_delta) {
    return ret;
  }
  
  double const pa1 = potential_altitude(previous->pta.alt, previous->mot);
  double const pa2 = potential_altitude(current .pta.alt, current .mot);

  // std::cout << "pa1: " << pa1 << std::endl;
  // std::cout << "pa2: " << pa2 << std::endl;
  double const climbrate = (pa2 - pa1) / dt;
  // std::cout << "cr: " << climbrate << std::endl;
  if (climbrate >= params.min_climbrate) {
    // TODO: Use in-between position?
    ret.pt        = current.pta;
    ret.climbrate = climbrate;
  }
  return ret;
}

void cpl::ogn::update(cpl::ogn::thermal_detector_params const& params,
                      cpl::ogn::thermal_tileset& tts, 
                      cpl::ogn::thermal const& th) {
  if (!valid(th.pt) || !tts.inside(th.pt)) {
    return;
  }

  // Add another dot-size to make the dots rounder... :)
  auto const r2 = cpl::math::square(params.dot_size - 1) + params.dot_size;

  for (int z = tts.minzoom(); z <= tts.maxzoom(); ++z) {
    // TODO: Optimize this!  Currently, for each zoom level the
    // Mercator projection is recomputed
    auto const fc = tts.mapper().get_full_coordinates(z, th.pt);
    auto& tile = tts.tile_at_create(z, fc.tile);

    for (int y =  fc.pixel.y - params.dot_size + 1; 
             y <= fc.pixel.y + params.dot_size - 1; ++y) {
    for (int x =  fc.pixel.x - params.dot_size + 1; 
             x <= fc.pixel.x + params.dot_size - 1; ++x) {

      // round dots
      if (     cpl::math::square(x - fc.pixel.x)
           +   cpl::math::square(y - fc.pixel.y) <= r2
          && 0 <= x && x < tts.tilesize() && 0 <= y && y < tts.tilesize()) {
        cpl::ogn::update_thermal_aggregator(tile[x][y], th);
      }
    }}
  }
}

bool cpl::ogn::has_identification(const vehicle_data& d) {
  return d.identify
      and (   not cpl::util::is_trivial_string(d.name1)
           or not cpl::util::is_trivial_string(d.name2));
}

bool cpl::ogn::full_participation(const vehicle_data& d) {
  return d.identify and d.tracking;
}

long cpl::ogn::memory_consumption(const cpl::ogn::aprs_info& a) {
  return   cpl::util::memory_consumption(a.tocall)
         + cpl::util::memory_consumption(a.relay )
         + cpl::util::memory_consumption(a.from  )
         ;
}

long cpl::ogn::memory_consumption(const cpl::ogn::vehicle_data& d) {
  return   cpl::util::memory_consumption(d.name1)
         + cpl::util::memory_consumption(d.name2)
         + cpl::util::memory_consumption(d.type )
 
         + cpl::util::memory_consumption(d.tracking)
         + cpl::util::memory_consumption(d.identify)
         + cpl::util::memory_consumption(d.id_type_probably_wrong)
         ;
}

long cpl::ogn::memory_consumption(const versions& v) {
  return   cpl::util::memory_consumption(v.hardware)
         + cpl::util::memory_consumption(v.software)
         ;
}

long cpl::ogn::memory_consumption(const rx_info& r) {
  return   cpl::util::memory_consumption(r.received_by)
         + cpl::util::memory_consumption(r.radio_id)
         + cpl::util::memory_consumption(r.rssi)
         + cpl::util::memory_consumption(r.frequency_deviation)
         + cpl::util::memory_consumption(r.errors)
         + cpl::util::memory_consumption(r.is_relayed)
         +            memory_consumption(r.aprs)
         ;
}

long cpl::ogn::memory_consumption(const aircraft_rx_info& a) {
  return   cpl::util::memory_consumption(a.id_type)
         + cpl::util::memory_consumption(a.vehicle_type)
         + cpl::util::memory_consumption(a.process)
         + cpl::util::memory_consumption(a.stealth)
         +            memory_consumption(a.ver)
         +            memory_consumption(a.data)
         + cpl::util::memory_consumption(a.pta)
         + cpl::util::memory_consumption(a.mot)
         + cpl::util::memory_consumption(a.baro_alt)
         +            memory_consumption(a.rx)
         ;
}

long cpl::ogn::memory_consumption(const station_info& si) {
  return   cpl::util::memory_consumption(si.network)
         + cpl::util::memory_consumption(si.pt)

         + cpl::util::memory_consumption(si.cpu_load)
         + cpl::util::memory_consumption(si.ram_used_mb)
         + cpl::util::memory_consumption(si.ram_available_mb)
         + cpl::util::memory_consumption(si.ntp_difference)
         + cpl::util::memory_consumption(si.ntp_ppm)

         + cpl::util::memory_consumption(si.temperature)
         +            memory_consumption(si.version)
         ;
}

namespace {

void test_q(
    std::ostream& os,
    const std::string& s,
    const std::string& tocall,
    const std::string& relay,
    const std::string& from) {
  os << "Testing q construct: " << s << std::endl;
  cpl::ogn::aprs_info q;
  always_assert(parse_qas_construct(s, q));
  always_assert(q.tocall == tocall);
  always_assert(q.relay  == relay );
  always_assert(q.from   == from  );
}

} // anonymous namespace

bool cpl::ogn::validate_station_name(const std::string& name) {
  return cpl::util::verify_alnum(name, cpl::util::allowed_characters_3(), false);
}

void cpl::ogn::unittests(std::ostream& os) {
  double lat1 = 1, lon1 = 2;
  double lat2 = -1, lon2 = -2;

  os << "OGN unit tests" << std::endl;
  always_assert(set_latlon_dao("!W55!", lat1, lon1));
  always_assert(set_latlon_dao("!W55!", lat2, lon2));

  os << std::setprecision(8) << lat1 << ' ' << lon1 << std::endl;
  os << std::setprecision(8) << lat2 << ' ' << lon2 << std::endl;

  double lat3 = 3, lon3 = 4;
  always_assert(set_latlon_dao("!w&(!", lat3, lon3));
  os << std::setprecision(8) << lat3 << ' ' << lon3 << std::endl;

  test_hide_id(os, "flarm:DEAB23", 4  , 'X');
  test_hide_id(os, "flarm:DEAB23", 0  , 'X');
  test_hide_id(os, "flarm:DEAB23", 6  , 'X');
  test_hide_id(os, "flarm:DEAB23", 100, 'X');
  test_hide_id(os, "icao:"       , 100, 'X');
  test_hide_id(os, "icao:"       , 0  , 'X');
  test_hide_id(os, "flarm342"    , 0  , 'X');
  test_hide_id(os, "flarm342"    , 3  , 'X');

  test_q(os, "OGFLARM-1,qAS,LFLE", "OGFLARM-1", "", "LFLE");
  test_q(os, "APRS,RELAY*,qAS,EPLR", "APRS", "RELAY*", "EPLR");

  always_assert("foo"     == cpl::ogn::id_type("foo:DEAB23"));
  always_assert("unknown" == cpl::ogn::id_type("DEAB23"));
  always_assert("DEAB23"  == cpl::ogn::unqualified_id("foo:DEAB23"));

  os << "Memory consumption of empty vehicle_data: "
     << cpl::ogn::memory_consumption(cpl::ogn::vehicle_data())
     << std::endl;
  os << "Memory consumption of aircraft_rx_info: "
     << cpl::ogn::memory_consumption(cpl::ogn::aircraft_rx_info())
     << std::endl;
}
